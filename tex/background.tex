%!TEX root = ClementiBarba2020.tex

\subsection{Verification, validation, reproducibility and replication}

Verification and validation of computational models---often abbreviated V\&V and viewed in concert---has developed into a mature subject with more than two decades of organized efforts to standardize it, dedicated conferences, and a  journal. 
The American Society of Mechanical Engineers (ASME), a standards-developing organization, formed its first Verification and Validation committee (known as V\&V 10) in 2001, with the charter: 
``to develop standards for assessing the correctness and credibility of modeling and simulation in computational solid mechanics.''
It approved its first document in 2006: The Guide for Verification and Validation in Computational Solid Mechanics (known as V\&V 10-2006). 
The fact that this guide was five years in the making illustrates just how complex the subject matter, and building consensus about it, can be. 
Since that first effort, six additional standards sub-committees have tackled V\&V in a variety of contexts. 
V\&V 70 is the latest, focused on machine-learning models.
The key principles laid out in the first V\&V standard persevere through the many subsequent efforts that have operated to this day. 
They are:

\begin{enumerate}

\item[$\triangleright$] Verification must precede validation.
\item[$\triangleright$] The need for validation experiments and the associated accuracy requirements for computational model predictions are based on the intended use of the model.
\item[$\triangleright$] Validation of a complex system should be pursued in a hierarchical fashion from the component level to the system level.
\item[$\triangleright$] Validation is specific to a particular computational model for a particular intended use.
\item[$\triangleright$] Validation must assess the predictive capability of the model in the physical realm of interest, and it
must address uncertainties that arise from both simulation results and experimental data.

\end{enumerate}

The process of \emph{verification} establishes that a computational model correctly describes the intended mathematical equations and their solutions.
It encompasses both code correctness, and solution accuracy.
\emph{Validation}, on the other hand, seeks to determine to which measure a computational model represents the physical world. 
We like to say that ``verification is solving the equations right, and validation is solving the right equations'' (source unknown). 
But in reality the exercise can be much more complicated than this sounds. 
Computational models in most cases are built in a hierarchy of simplifications and approximations, and comparing with the physical world means conducting experiments, which themselves carry uncertainties. 

As we will discuss in this paper, verification and validation in contexts that involve complex physics at less tractable scales (either very small, or very large), or where experimental methods are nascent, proceeds in a tangle of researcher judgements and path finding. 
In practice, validation activities reported in the scholarly literature often concentrate on using a stylized benchmark, and comparing experimental measurements with the results from computational models on that benchmark. 
Seldom do these activities address the key principles of pursuing validation in a hierarchical fashion from the component to the system level, and of assessing the predictive capability of the computational model accounting for various sources of uncertainties. 
Comprehensive validation studies are difficult, expensive, and time consuming. 
Often, they are severely limited by practical constraints, and the conclusions equivocal. 
Yet the computational models still provide useful insights into the research or engineering question at hand, and we build trust on them little by little.

Verification and validation align on one axis of the multi-dimensional question of when are claims to knowledge arising from modeling and simulation justified, credible, true \cite{winsberg-2010}.
Two other axes of this question are: reproducibility and replication, and uncertainty quantification (UQ).
Uncertainty quantification uses statistical methods to give objective confidence levels for the results of simulations. 
Uncertainties typically stem from input data, modeling errors, genuine physical uncertainties, random processes, and so on. 
A scientific study may be reproducible, the simulations within it undergone V\&V, yet the results are still uncertain. 
Building confidence in scientific findings obtained through computational modeling and simulation entails efforts in the three ``axes of truth'' described here.

Reproducibility and replication (we could call it R\&R) preoccupy scientific communities more recently. 
Agreement on the terminology, to begin with, has been elusive \cite{barba2018}. 
The National Academies of Science, Engineering and Medicine (NASEM) released in May 2019 a consensus study report on Replicability and Reproducibility in Science \cite{NASEM2019} with definitions as follows.
``Reproducibility is obtaining consistent results using the same input data, computational steps, methods, and code, and conditions of analysis.
Replicability is obtaining consistent measurements or results, or drawing consistent conclusions using new data, methods, or conditions, in a study aimed at the same scientific question.''
According to these definitions, reproducibility demands full transparency of the computational workflow, which at the very least means open code and open data, where `open` means shared at time of publication (or earlier) under a standard public license. 
This condition is infrequently satisfied.
The NASEM report describes how a number of systematic efforts to reproduce computational results have failed in more than half of the attempts made, mainly due to insufficient detail on digital artifacts, such as data, code and computational workflow \cite{moraila-etal-2014,iqbal-etal-2016,chang-li2018,stodden-etal-2018}. 
Recommendation 4-1 of the NASEM report states that 
``to help ensure reproducibility of computational results, researchers should convey clear, specific, and complete information about any computational methods and data products that support their published results in order to enable other researchers to repeat the analysis, unless such information is restricted by nonpublic data policies. That information should include the data, study methods, and computational environment'' \cite{NASEM2019}.

Although it may seem evident that running an analysis with identical inputs would result in identical outputs, this is sometimes not true. 
For example, the combination of floating-point representation of numbers and parallel processing means that running the same software with the same input data may give different numerical results. 
In some research settings, it may make sense to relax the requirement of bitwise reproducibility and settle on reproducible results within an accepted range of variation (or uncertainty). 
This can only be decided, however, after fully understanding the numerical-analysis issues affecting the outcomes---and the risk associated with an uncertainty range. 
Researchers using high-performance computing thus recognize that when different runs with the same input data produce slightly different numeric outputs, each of these results is equally credible, and the output must be understood as an approximation to the correct value within a certain accepted uncertainty.

Beyond the particulars of high-performance or parallel computing, what makes reproducibility so difficult to achieve? 
A number of factors can contribute to the lack of reproducibility in research. 
In addition to lack of access to non-public data and code, the NASEM report lists the following contributors to lack of reproducibility:

\begin{enumerate}

\item[$\triangleright$] Inadequate record-keeping: the original researchers did not properly record the relevant digital artifacts such as protocols or steps followed to obtain the results, the details of the computational environment and software dependencies, and/or information on the archival of all necessary data.
\item[$\triangleright$]  Non-transparent reporting: the original researchers did not transparently report and provide open access to or archive the relevant digital artifacts necessary for reproducibility.
\item[$\triangleright$]  Obsolescence of the digital artifacts: over time, the digital artifacts in the research compendium are compromised because of technological breakdown and evolution or lack of continued curation.
\item[$\triangleright$]  Flawed attempts to reproduce others' research: the researchers who attempted to reproduce the work lacked expertise or failed to correctly follow the research protocols.
\item[$\triangleright$]  Barriers in the culture of research: lack of resources and incentives to adopt computationally reproducible and transparent research across fields and researchers.

\end{enumerate}

Improving computational reproducibility hinges on capturing and sharing information about the computational environment and steps required to collect, process, and analyze data.
Scientific workflows represent a complex flow of data products through various steps of collection, transformation, and analysis to produce an interpretable result. 
Capturing provenance of the result is increasingly difficult to do using manual processes. 
Thus, to support computational reproducibility, efforts have been under way for several years to develop workflow-management systems that capture and store data and workflow provenance automatically. 
With such systems, results can be reliably linked to the computational process that derived them, and computational tasks can be automated, allowing them to be rerun and shared.
With regards to software management, version-control systems are used to automatically capture the history of all changes made to the source code of a computer program. 
This creates a history of changes and allows the developers to better understand the code and to identify possible problems or errors.
Recently, the concept of version control has been extended to data files. 
These files are generally too large to be stored in standard version-control systems, and they are often in a binary format that cannot be versioned. 
Rather, data version control excludes the large data files from the main versioned repository, automatically collects data provenance, records data processing steps into a (reproducible) pipeline, and connects with cloud services where large data files are stored.
Recent technological advances in version control, virtualization, computational notebooks, and automatic provenance tracking have the potential to simplify reproducibility, and tools have been developed that leverage these technologies.
Still many questions remain answered both to understand the gaps left by existing tools and to develop principled approaches that fill those gaps. 



\subsection{Description of the PyGBe software}

Our research group has been developing PyGBe---pronounced \emph{pigb\={e}}---for several years. 
It was first written for biomolecular-electrostatics calculations using a continuum model of proteins in water or an ionic solution. 
The solution method applies a boundary integral approximation of the governing Poisson-Boltzmann or Poisson equations, to obtain electrostatic field and potential on the molecular surface. 
In the implicit-solvent model, this information is used to compute the quantity of interest: solvation energy, which is diagnostic for questions of protein binding affinity, protein-surface interactions, and others. 
PyGBe uses a fast-summation algorithm via a Barnes-Hut treecode \cite{BarnesHut1986}, and accelerates the computationally intensive parts of the code on NVIDIA GPU hardware using CUDA kernels in the treecode, interfacing with PyCUDA \cite{klockner2012pycuda}. 
Other portions of the code are written in C$++$, wrapped using \texttt{swig}, to extract more performance \cite{CooperETal2016}. 


\subsection{Physics context for this work}


